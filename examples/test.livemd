<!-- livebook:{"file_entries":[{"name":"cat.jpg","type":"attachment"}]} -->

# ExVision demo

```elixir
Mix.install([
  {:ex_vision, ">= 0.0.0", path: Path.join(__DIR__, "..")},
  :kino,
  :kino_bumblebee
])
```

## Introduction

ExVision is meant to be a library of exported ONNX models packaged in an easy to use and intuitive API.

1. It's meant to provide an intuitive and well documented API for the models, especially regarding the inputs and outputs of models.
2. It should provide understandable and easy to process outputs that make sense.
   For example, for classification models, the most logical output format is a dictionary with class probabilities.

## Demo

```elixir
alias ExVision.Classification.MobileNetV3
model = MobileNetV3.load()
```

Let's fetch the image of the cat

```elixir
cat_path = Path.join(__DIR__, "files/cat.jpg")
Kino.Image.new(File.read!(cat_path), "image/jpeg")
```

And try to classify it. We're getting a dictionary of probabilities as a result, thanks to us a few lines of postprocessing happening on the backend.

```elixir
result = ExVision.Model.run(model, cat_path)
```

```elixir
result
|> Enum.to_list()
|> Enum.sort_by(&elem(&1, 1), :desc)
|> Enum.take(10)
|> Kino.Bumblebee.ScoredList.new()
```

## Interactive demo

```elixir
inputs = [
  image: Kino.Input.image("image", format: :jpeg)
]

output = Kino.Frame.new()
form = Kino.Control.form(inputs, submit: "Send", reset_on_submit: [:message])

Kino.listen(form, fn %{data: %{image: %{file_ref: image_ref}}} ->
  path = Kino.Input.file_path(image_ref)

  model
  |> ExVision.Model.run(path)
  |> Enum.to_list()
  |> Enum.sort_by(&elem(&1, 1), :desc)
  |> Enum.take(10)
  |> Kino.Bumblebee.ScoredList.new()
  |> then(&Kino.Frame.render(output, &1))
end)

Kino.Layout.grid([form, output])
```
